{"componentChunkName":"component---src-pages-ibmcloud-replication-index-mdx","path":"/ibmcloud/replication/","result":{"pageContext":{"frontmatter":{"title":"Implementing Near Real-time or Scheduled Data Replication Framework using Parmiko"},"relativePagePath":"/ibmcloud/replication/index.mdx","titleType":"page","MdxNode":{"id":"494cd8fd-81e7-5f63-8821-8ade0037f40d","children":[],"parent":"39131ac5-53b0-53cb-bd8f-c21125f788f3","internal":{"content":"---\ntitle: Implementing Near Real-time or Scheduled Data Replication Framework using Parmiko\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\n\n</PageDescription>\n\n# Reference Architecture\n![Alt text](images/Screenshot_4_lat.jpg) \n\n\nThe current scenario discusses real-time replication between two computes, however this can be customized to work with multiple machines. The solution is tested on RHEL8 machine on IBM Cloud's VPC based network.\n\nThe private network can be either cloud-based network or on-prem data center network. Data can come from public Internet or generated by internal processes and stored on local disks or SAN volumes. This data can be replicated in real-time or scheduled for later replication depending on Individual requirements. The solution makes use of paramiko framework available in Python, the details of which are mentioned in below sections.  \n\nThe python replication service runs as systemd service on RHEL and starts automatically when OS is restarted. Any time data is loaded into landing zone, this service replicates it to other computes it is configured for. This service needs to be installed and confirmed on all participating peer machines for cross replication. This service will not replicate data which is currently downloading, in RHEL it has a **.filepart** extension and wait for it to completely download before action on it. The additional extensions (if any) can be added in the service code. \n\nThis also talks about performance measurement for data transfer between two machines.\n\n# Parmiko\nParamiko primarily supports POSIX platforms with standard OpenSSH implementations, and is most frequently tested on Linux and OS X. Windows is supported as well, though it may not be as straightforward. Details can be found in below git-hub link:\n\nhttps://github.com/paramiko/paramiko\n\n--------------------\n# Meeting the Pre-requisites\ndnf install python3 \npip3 install schedule  \npip3 install setuptools-rust \npip3 install wheel \npip3 install PyNaCl \npip3 install bcrypt \ndnf install redhat-rpm-config gcc libffi-devel python3-devel openssl-devel cargo \npip3 install paramiko \npip install loguru \n## Make Pre-requisite directories\nmkdir /upload \nchmod 777 /upload \nmkdir /archive \nchmod 777 /archive \n\n## Service Setup\na) Copy schedule_test_every_two_min.py in /opt or directory of your choice (make sure to modify service file in this case). \nb) Copy python-scheduler.service in /etc/systemd/system directory. \nc) Run systemctl daemon-reload\nd) Run systemd-analyze verify python-scheduler.service to ensure that file is correct. If it is correct it should not return any output. \ne) Run systemctl enable python-scheduler.service to enable service to start automatically on system restart. \nf) Run systemctl start python-scheduler.service \ng) Run systemctl status python-scheduler.service to check the status of service. \n\n## SSH Session Timeout\nThe ClientAliveInterval parameter specifies the time in seconds that the server will wait before sending a null packet to the client system to keep the connection alive.\n\nOn the other hand, the ClientAliveCountMax parameter defines the number of client alive messages which are sent without getting any messages from the client. If this limit is reached while the messages are being sent, the sshd daemon will drop the session, effectively terminating the ssh session.\n\nTimeout value = ClientAliveInterval * ClientAliveCountMax\n\nExample: \nClientAliveInterval  1200 \nClientAliveCountMax 3 \n\nThe Timeout value will be 1200 seconds * 3 = 3600 seconds. \nThis is an equivalent of 1 hour, which implies that your ssh session will remain alive for idle time of 1 hour without dropping.\n\nAlternatively, you can achieve the same result by specifying the ClientAliveInterval parameter alone.\n\nClientAliveInterval  3600\n\nOnce done, reload the OpenSSH daemon for the changes to come into effect.\n\n## Performance Measurement\ndnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm \ndnf install nload \nnload -m \n![Alt text](images/Screenshot_1.jpg?raw=true \"\")\n# nload commands\n![Alt text](images/Screenshot_2.jpg?raw=true \"\") \n# Where \n![Alt text](images/Screenshot_3.jpg?raw=true \"\")\n\n# Example Scenario - File is externally uploaded to virtual server ftom WinSCP and this will is replicated to second virtual server through python code\n# Step1 - Uploading File \n\nAfter file transfer is started one can verify download speed as below \n![Alt text](images/Screenshot_1_lat.jpg?raw=true \"\") \n\nOne the upload is complete to first virtual server, python scheduler will replicate the data to second virtual server as shown below, one can not both outbound transfer rate on first server and inbound rate on second server  - \n\n![Alt text](images/Screenshot_2_lat.jpg?raw=true \"\")\n\nThe schedule will not initiate transfer during downloading process \n\n![Alt text](images/Screenshot_3_lat.jpg?raw=true \"\") \n\n# Running Scheduler as Systemd Service\nCopy python-scheduler.service in /etc/systemd/system directory.\n![Alt text](images/Screenshot_5_lat.jpg?raw=true \"\") \n\n### Note: Entry Environment=PYTHONUNBUFFERED=1 in systemd service file ensures that the logging is not buffered and is real time. The logging is generated in /var/log/messages file\n\n## Reference:\nhttps://cryptography.io/en/3.4.5/installation.html \nhttp://www.paramiko.org/installing.html#cryptography \nhttps://www.programcreek.com/python/example/4561/paramiko.SSHClient \nhttps://www.cyberciti.biz/faq/how-to-test-the-network-speedthroughput-between-two-linux-servers/ \nhttps://www.cyberciti.biz/faq/linux-unix-test-internet-connection-download-upload-speed/ \nhttps://phoenixnap.com/kb/linux-network-speed-test \nhttps://www.cyberciti.biz/faq/linux-unix-test-internet-connection-download-upload-speed/ \n","type":"Mdx","contentDigest":"a8ad6e3ba151afe17c2a3ce026ecb39a","owner":"gatsby-plugin-mdx","counter":905},"frontmatter":{"title":"Implementing Near Real-time or Scheduled Data Replication Framework using Parmiko"},"exports":{},"rawBody":"---\ntitle: Implementing Near Real-time or Scheduled Data Replication Framework using Parmiko\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\n\n</PageDescription>\n\n# Reference Architecture\n![Alt text](images/Screenshot_4_lat.jpg) \n\n\nThe current scenario discusses real-time replication between two computes, however this can be customized to work with multiple machines. The solution is tested on RHEL8 machine on IBM Cloud's VPC based network.\n\nThe private network can be either cloud-based network or on-prem data center network. Data can come from public Internet or generated by internal processes and stored on local disks or SAN volumes. This data can be replicated in real-time or scheduled for later replication depending on Individual requirements. The solution makes use of paramiko framework available in Python, the details of which are mentioned in below sections.  \n\nThe python replication service runs as systemd service on RHEL and starts automatically when OS is restarted. Any time data is loaded into landing zone, this service replicates it to other computes it is configured for. This service needs to be installed and confirmed on all participating peer machines for cross replication. This service will not replicate data which is currently downloading, in RHEL it has a **.filepart** extension and wait for it to completely download before action on it. The additional extensions (if any) can be added in the service code. \n\nThis also talks about performance measurement for data transfer between two machines.\n\n# Parmiko\nParamiko primarily supports POSIX platforms with standard OpenSSH implementations, and is most frequently tested on Linux and OS X. Windows is supported as well, though it may not be as straightforward. Details can be found in below git-hub link:\n\nhttps://github.com/paramiko/paramiko\n\n--------------------\n# Meeting the Pre-requisites\ndnf install python3 \npip3 install schedule  \npip3 install setuptools-rust \npip3 install wheel \npip3 install PyNaCl \npip3 install bcrypt \ndnf install redhat-rpm-config gcc libffi-devel python3-devel openssl-devel cargo \npip3 install paramiko \npip install loguru \n## Make Pre-requisite directories\nmkdir /upload \nchmod 777 /upload \nmkdir /archive \nchmod 777 /archive \n\n## Service Setup\na) Copy schedule_test_every_two_min.py in /opt or directory of your choice (make sure to modify service file in this case). \nb) Copy python-scheduler.service in /etc/systemd/system directory. \nc) Run systemctl daemon-reload\nd) Run systemd-analyze verify python-scheduler.service to ensure that file is correct. If it is correct it should not return any output. \ne) Run systemctl enable python-scheduler.service to enable service to start automatically on system restart. \nf) Run systemctl start python-scheduler.service \ng) Run systemctl status python-scheduler.service to check the status of service. \n\n## SSH Session Timeout\nThe ClientAliveInterval parameter specifies the time in seconds that the server will wait before sending a null packet to the client system to keep the connection alive.\n\nOn the other hand, the ClientAliveCountMax parameter defines the number of client alive messages which are sent without getting any messages from the client. If this limit is reached while the messages are being sent, the sshd daemon will drop the session, effectively terminating the ssh session.\n\nTimeout value = ClientAliveInterval * ClientAliveCountMax\n\nExample: \nClientAliveInterval  1200 \nClientAliveCountMax 3 \n\nThe Timeout value will be 1200 seconds * 3 = 3600 seconds. \nThis is an equivalent of 1 hour, which implies that your ssh session will remain alive for idle time of 1 hour without dropping.\n\nAlternatively, you can achieve the same result by specifying the ClientAliveInterval parameter alone.\n\nClientAliveInterval  3600\n\nOnce done, reload the OpenSSH daemon for the changes to come into effect.\n\n## Performance Measurement\ndnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm \ndnf install nload \nnload -m \n![Alt text](images/Screenshot_1.jpg?raw=true \"\")\n# nload commands\n![Alt text](images/Screenshot_2.jpg?raw=true \"\") \n# Where \n![Alt text](images/Screenshot_3.jpg?raw=true \"\")\n\n# Example Scenario - File is externally uploaded to virtual server ftom WinSCP and this will is replicated to second virtual server through python code\n# Step1 - Uploading File \n\nAfter file transfer is started one can verify download speed as below \n![Alt text](images/Screenshot_1_lat.jpg?raw=true \"\") \n\nOne the upload is complete to first virtual server, python scheduler will replicate the data to second virtual server as shown below, one can not both outbound transfer rate on first server and inbound rate on second server  - \n\n![Alt text](images/Screenshot_2_lat.jpg?raw=true \"\")\n\nThe schedule will not initiate transfer during downloading process \n\n![Alt text](images/Screenshot_3_lat.jpg?raw=true \"\") \n\n# Running Scheduler as Systemd Service\nCopy python-scheduler.service in /etc/systemd/system directory.\n![Alt text](images/Screenshot_5_lat.jpg?raw=true \"\") \n\n### Note: Entry Environment=PYTHONUNBUFFERED=1 in systemd service file ensures that the logging is not buffered and is real time. The logging is generated in /var/log/messages file\n\n## Reference:\nhttps://cryptography.io/en/3.4.5/installation.html \nhttp://www.paramiko.org/installing.html#cryptography \nhttps://www.programcreek.com/python/example/4561/paramiko.SSHClient \nhttps://www.cyberciti.biz/faq/how-to-test-the-network-speedthroughput-between-two-linux-servers/ \nhttps://www.cyberciti.biz/faq/linux-unix-test-internet-connection-download-upload-speed/ \nhttps://phoenixnap.com/kb/linux-network-speed-test \nhttps://www.cyberciti.biz/faq/linux-unix-test-internet-connection-download-upload-speed/ \n","fileAbsolutePath":"/home/runner/work/ibm-enterprise-runbooks/ibm-enterprise-runbooks/src/pages/ibmcloud/replication/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","243517648","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550","817386451"]}